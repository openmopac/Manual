<html>
<head>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MTDKH6F');</script>
<!-- End Google Tag Manager -->


<title>Convergence in SCF Calculation</title>
</head>
<body bgcolor="#ffffff" link="#0000ff" vlink="#800080">

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MTDKH6F"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


<h2>Convergence in SCF Calculation </h2>
<p>A brief description of the convergence techniques used in subroutine ITER follows. </p>
<p>ITER, the SCF calculation, employs six methods to achieve a self-consistent field. In order of usage, these are: </p>
<dl>
<dd>&nbsp;</dd>
<dt>1. Intrinsic convergence by virtue of the way the calculation is carried out. Thus a trial Fock gives rise to a trial density matrix, which in turn is used to generate a better Fock matrix. </dt>
This is normally convergent, but many exceptions are known. The main situations when the intrinsic convergence does not work are: 
<dt>(a) A bad starting density matrix. This normally occurs when the default starting density matrix is used. This is a very crude approximation, and is only used to get the calculation started. A large charge is generated on an atom in the first iteration, the second iteration overcompensates, and an oscillation is generated. </dt>
<dt>(b) The equations are only very slowly convergent. This can be due to a long-lived oscillation or to a slow transfer of charge. </dt>
<dd>&nbsp;</dd>
<dt>2. Oscillation damping. If, on any two consecutive iterations, a density matrix element changes by more than 0.05, then the density matrix element is set equal to the old element shifted by 0.05 in the direction of the calculated element. Thus, if on iterations 3 and 4 a certain density matrix element was 0.55 and 0.78, respectively, then the element would be set to 0.60 (= 0.55 + 0.05) on iteration 4. The density matrix from iteration 4 would then be used in the construction of the next Fock matrix. The arrays which hold the old density matrices are not filled until after iteration 2. For this reason they are not used in the damping before iteration 3. 
Not used by <a href="mozyme.html"><tt>MOZYME</tt></a></dt>
<dd>&nbsp;</dd>
<dt>3. Three-point interpolation of the density matrix. Subroutine CNVG monitors the number of iterations, and if this is exactly divisible by three, and certain other conditions relating to the density matrices are satisfied, a three-point interpolation is performed. This is the default converger, and is very effective with normally convergent calculations. It fails in certain systems, usually those where significant charge build-up is present. 
Not used by <a href="mozyme.html"><tt>MOZYME</tt></a></dt>
<dd>&nbsp;</dd>
<dt>4. Energy-level shift technique (the <tt>SHIFT</tt> technique). The virtual M.O. energy levels are normally shifted to more positive energy. This has the effect of damping oscillations, and intrinsically divergent equations can often be changed to intrinsically convergent form. With slowly-convergent systems the virtual M.O. energy levels can be moved to a more negative value. </dt>
The precise value of the shift used depends on the behavior of the iteration energy. If it is dropping, then the HOMO-LUMO gap is reduced; if the iteration energy rises, the gap is increased rapidly. 
Not used by <a href="mozyme.html"><tt>MOZYME</tt></a>
<dt>&nbsp;</dt>
<dt>5. Pulay's method. If requested, when the largest change in density matrix elements on two consecutive iterations has dropped below 0.1, then routine CNVG is abandoned in favor of a multi-Fock matrix interpolation. This relies on the fact that the eigenvectors of the density and Fock matrices are identical at self-consistency, so [P.F] = (P.F - F.P) = 0 at SCF. The extent to which this condition does not occur is a measure of the deviance from self-consistency. Pulay's Direct Inversion of the Iterative Subspace (DIIS) method uses this relationship to calculate that linear combination of Fock matrices which minimize [P.F]. This new Fock matrix is then used in the SCF calculation. </dt>
Under certain circumstances, Pulay's method can cause very slow convergence, but sometimes it is the only way to achieve a self-consistent field. At other times the procedure gives a ten-fold increase in speed, so care must be exercised in its use. (started by the keyword <tt>PULAY</tt>) 
Not used by <a href="mozyme.html"><tt>MOZYME</tt></a>
<dt>&nbsp;</dt>
<dt>6. The Camp-King converger. If all else fails, the Camp-King <a name="BM11267">&nbsp;</a> converger is just about guaranteed to work every time. However, it is time-consuming, and therefore should only be started as a last resort. </dt>
It evaluates that linear combination of old and current eigenvectors which minimize the total energy. One of its strengths is that systems which otherwise oscillate due to charge surges, e.g. CHO-H, the C-H distance being very large, will converge using this very sophisticated converger. 
Not used by <a href="mozyme.html"><tt>MOZYME</tt></a>
<dt>&nbsp;<dt>7. In a <a href="mozyme.html"><tt>MOZYME</tt></a> calculation, damp SCF 
oscillations using <a href="damp.html"><tt>DAMP</tt></a>=n.nn, where <i>n.nn</i> should be in the range 
1.0 &lt;<i> n.nn </i>&lt; 0.0.&nbsp; Values in the region of 0.5 are usually 
successful.&nbsp; For solids, the default factor is 0.5, so <i>n.nn </i>should 
be less that 0.5.</dt>
</dt></dl>
<p>&nbsp;</p>
</body>
</html>